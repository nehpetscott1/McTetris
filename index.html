<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tetris — MC Classroom + Tutorial (SRS/T-Spin/PC)</title>
  <link rel="stylesheet" href="styles.css"/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet"/>
</head>
<body>
  <!-- [HTML content unchanged, use your original HTML for all panels, modals, etc.] -->
  <!-- Only the script is fixed below! -->
  <script>
    // Utility
    function mustGet(id) { const el = document.getElementById(id); if (!el) throw new Error("Missing element #" + id); return el; }
    const store = {
      get: (k, f = "{}") => { try { return localStorage.getItem(k) ?? f; } catch { return f; } },
      set: (k, v) => { try { localStorage.setItem(k, v); return true; } catch { return false; } }
    };

    // Constants
    const BOARD_WIDTH = 10, BOARD_HEIGHT = 20;
    const INITIAL_SPEED = 500;
    let LOCK_DELAY = 500;
    const SOFT_POINT = 1, HARD_POINT = 2;
    const LINE_SCORE = [0, 100, 300, 500, 800];
    const TSPIN_BONUS = 400;
    const PERFECT_CLEAR_BONUS = 1800;

    // Pieces
    const TETROMINOES = {
      I: { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], class: 'color-I', id: 1 },
      O: { shape: [[1, 1], [1, 1]], class: 'color-O', id: 3 },
      T: { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], class: 'color-T', id: 2 },
      S: { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], class: 'color-S', id: 4 },
      Z: { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], class: 'color-Z', id: 5 },
      J: { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], class: 'color-J', id: 6 },
      L: { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], class: 'color-L', id: 7 }
    };
    const TYPES = Object.keys(TETROMINOES);

    // SRS Wall-Kicks
    const SRS_JLSTZ = {
      "0>1": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
      "1>0": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
      "1>2": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
      "2>1": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
      "2>3": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
      "3>2": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
      "3>0": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
      "0>3": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]]
    };
    const SRS_I = {
      "0>1": [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
      "1>0": [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
      "1>2": [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]],
      "2>1": [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
      "2>3": [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
      "3>2": [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
      "3>0": [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
      "0>3": [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]]
    };

    // UI References
    const gameBoard = mustGet('gameBoard');
    const startModal = mustGet('startModal');
    const gameOverModal = mustGet('gameOverModal');
    const pauseModal = mustGet('pauseModal');
    const keysModal = mustGet('keysModal');
    const tutorialModal = mustGet('tutorialModal');

    const startBtn = mustGet('startBtn');
    const pauseBtn = mustGet('pauseBtn');
    const rotateBtn = mustGet('rotateBtn');
    const dropBtn = mustGet('dropBtn');
    const holdBtn = mustGet('holdBtn');
    const keysBtn = mustGet('keysBtn');
    const tutorialBtn = mustGet('tutorialBtn');

    const scoreEl = mustGet('score');
    const linesEl = mustGet('lines');
    const levelEl = mustGet('level');
    const holdBox = mustGet('holdBox');
    const nextList = mustGet('nextList');

    const optAdaptive = mustGet('optAdaptive');
    const optLock = mustGet('optLock');
    const optDaily = mustGet('optDaily');
    const optSeed = mustGet('optSeed');
    const optQueue = mustGet('optQueue');
    const optGhost = mustGet('optGhost');
    const optSymbolic = mustGet('optSymbolic');
    const exportBtn = mustGet('exportBtn');

    // Keybind inputs
    const kb = {
      modal: keysModal,
      left: mustGet('kbLeft'),
      right: mustGet('kbRight'),
      down: mustGet('kbDown'),
      rotate: mustGet('kbRotate'),
      hard: mustGet('kbHard'),
      hold: mustGet('kbHold'),
      pause: mustGet('kbPause'),
      save: mustGet('kbSave'),
      cancel: mustGet('kbCancel')
    };

    // Tutorial UI
    const tut = {
      modal: tutorialModal,
      body: mustGet('tutBody'),
      next: mustGet('tutNext'),
      prev: mustGet('tutPrev'),
      exit: mustGet('tutExit'),
      step: 0,
      active: false,
      practiceMode: false
    };

    // Audio
    let AC = null;
    function ac() { if (!AC) { AC = new (window.AudioContext || window.webkitAudioContext)(); } return AC; }
    function beep(freq = 440, dur = 0.06, gain = 0.03) {
      try {
        const ctx = ac();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = 'square'; o.frequency.value = freq; g.gain.value = gain;
        o.connect(g); g.connect(ctx.destination);
        const t = ctx.currentTime; o.start(t); o.stop(t + dur);
      } catch { }
    }
    const SND = {
      rotate: () => beep(740, 0.05, 0.025),
      move: () => beep(520, 0.03, 0.02),
      drop: () => beep(960, 0.05, 0.03),
      line: () => beep(420, 0.06, 0.035),
      tspin: () => beep(300, 0.12, 0.05),
      pc: () => beep(220, 0.18, 0.06),
      over: () => beep(160, 0.25, 0.06)
    };

    // Game State and Stats
    let state = {};
    let rngSeed = Math.floor(Math.random() * 1e9) >>> 0;
    let queue = [], canHold = true, lockSince = null, loopHandle = 0;
    let lastActionWasRotate = false;
    let sessionStart = Date.now();
    const stats = { tspins: 0, perfects: 0 };
    const roll = { inputs: 0, soft: 0, hard: 0, mis: 0, locks: 0, lastInputAt: performance.now(), meanLatency: 0 };
    const CLASS_KEY = 'mc_tetris_classlog';

    // RNG / 7-BAG
    function dailySeed() { const d = new Date(); return (d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate()) >>> 0; }
    function xs32() { rngSeed ^= rngSeed << 13; rngSeed ^= rngSeed >>> 17; rngSeed ^= rngSeed << 5; return (rngSeed >>> 0) / 0xffffffff; }
    function newBag() {
      const arr = [1, 2, 3, 4, 5, 6, 7];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(xs32() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr.map(id => TYPES.find(k => TETROMINOES[k].id === id));
    }

    // Board / Piece Helpers
    function makeBoard() {
      gameBoard.innerHTML = '';
      state.board = Array.from({ length: BOARD_HEIGHT }, () => Array.from({ length: BOARD_WIDTH }, () => null));
      const frag = document.createDocumentFragment();
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const cell = document.createElement('div');
          cell.className = 'game-cell'; cell.dataset.x = String(x); cell.dataset.y = String(y);
          frag.appendChild(cell);
        }
      }
      gameBoard.appendChild(frag);
    }
    function spawnPiece(type) {
      const data = TETROMINOES[type];
      return {
        type: type,
        class: data.class,
        o: 0,
        shape: data.shape.map(r => r.slice()),
        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(data.shape[0].length / 2),
        y: -1
      };
    }
    function currentCells(piece) {
      const a = [];
      for (let py = 0; py < piece.shape.length; py++)
        for (let px = 0; px < piece.shape[py].length; px++)
          if (piece.shape[py][px]) a.push({ x: piece.x + px, y: piece.y + py });
      return a;
    }
    function validAt(board, piece, X, Y, shapeOverride = null) {
      const shp = shapeOverride || piece.shape;
      for (let py = 0; py < shp.length; py++) {
        for (let px = 0; px < shp[py].length; px++) {
          if (shp[py][px]) {
            const x = X + px, y = Y + py;
            if (x < 0 || x >= BOARD_WIDTH || y >= BOARD_HEIGHT) return false;
            if (y >= 0 && board[y][x]) return false;
          }
        }
      }
      return true;
    }
    function rotCW(shape) {
      const rows = shape.length, cols = shape[0].length;
      const out = Array.from({ length: cols }, () => Array(rows).fill(0));
      for (let r = 0; r < rows; r++)
        for (let c = 0; c < cols; c++)
          out[c][rows - 1 - r] = shape[r][c];
      return out;
    }
    function srsRotateCW(piece) {
      const from = piece.o, to = (piece.o + 1) & 3;
      const cand = rotCW(piece.shape);
      if (piece.type === 'O') {
        if (validAt(state.board, piece, piece.x, piece.y, cand))
          return { ok: true, x: piece.x, y: piece.y, shape: cand, o: to, kicked: false };
        return { ok: false };
      }
      const table = (piece.type === 'I') ? SRS_I : SRS_JLSTZ;
      const kicks = table[`${from}>${to}`];
      for (const [dx, dy] of kicks) {
        const nx = piece.x + dx, ny = piece.y + dy;
        if (validAt(state.board, piece, nx, ny, cand))
          return { ok: true, x: nx, y: ny, shape: cand, o: to, kicked: !(dx === 0 && dy === 0) };
      }
      return { ok: false };
    }
    function ghostY(board, piece) { let y = piece.y; while (validAt(board, piece, piece.x, y + 1)) y++; return y; }

    // Hold/Next
    function miniGrid(el, shape, cls) {
      el.innerHTML = '';
      for (let y = 0; y < 4; y++)
        for (let x = 0; x < 4; x++) {
          const c = document.createElement('div'); c.className = 'preview-cell';
          if (shape?.[y]?.[x]) c.classList.add(cls);
          el.appendChild(c);
        }
    }
    function drawHold() {
      const h = state.hold ? TETROMINOES[state.hold.type] : null;
      const sh = h ? h.shape : [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
      miniGrid(holdBox, sh, h ? h.class : '');
    }
    function drawNext() {
      const minis = [...nextList.querySelectorAll('.mini-grid')];
      for (let i = 0; i < minis.length; i++) {
        const t = queue[i]; const data = t ? TETROMINOES[t] : null;
        const blank = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
        miniGrid(minis[i], data ? data.shape : blank, data ? data.class : '');
        minis[i].style.display = i < state.queueSize ? 'grid' : 'none';
      }
    }

    // Display
    function updateDisplay() {
      for (const el of gameBoard.querySelectorAll('.game-cell')) el.className = 'game-cell';
      for (let y = 0; y < BOARD_HEIGHT; y++)
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const cls = state.board[y][x];
          if (cls) {
            const el = gameBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (el) el.className = `game-cell filled ${cls}`;
          }
        }
      if (state.ghost && state.cur) {
        const gy = ghostY(state.board, state.cur);
        for (const { x, y } of currentCells({ ...state.cur, y: gy })) {
          if (y >= 0) {
            const el = gameBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (el) { el.classList.add('ghost'); if (lockSince !== null) el.classList.add('lockPulse'); }
          }
        }
      }
      if (state.cur) {
        for (const { x, y } of currentCells(state.cur)) {
          if (y >= 0) {
            const el = gameBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (el) el.className = `game-cell filled ${state.cur.class}`;
          }
        }
      }
      scoreEl.textContent = String(state.score);
      linesEl.textContent = String(state.lines);
      levelEl.textContent = String(state.level);
    }

    // Gameplay
    function popNext() {
      while (queue.length < 7) queue = queue.concat(newBag());
      const type = queue.shift();
      state.cur = spawnPiece(type);
      lastActionWasRotate = false; lockSince = null;
      drawNext();
    }
    function holdSwap() {
      if (!canHold || !state.cur) return;
      const curType = state.cur.type;
      if (!state.hold) { state.hold = { type: curType }; popNext(); }
      else { const swap = state.hold.type; state.hold = { type: curType }; state.cur = spawnPiece(swap); }
      canHold = false; drawHold(); updateDisplay();
    }
    function move(dx, dy) {
      if (!state.cur) return false;
      const nx = state.cur.x + dx, ny = state.cur.y + dy;
      if (validAt(state.board, state.cur, nx, ny)) {
        state.cur.x = nx; state.cur.y = ny; if (dx !== 0) SND.move();
        if (dy > 0 && !validAt(state.board, state.cur, nx, ny + 1)) { if (lockSince === null) lockSince = performance.now(); }
        lastActionWasRotate = false; return true;
      }
      if (dy !== 0 && lockSince === null) lockSince = performance.now();
      return false;
    }
    function filledRows() { const rows = []; for (let y = 0; y < BOARD_HEIGHT; y++) { if (state.board[y].every(Boolean)) rows.push(y); } return rows; }
    function animateClearAndApply(rows, onDone) {
      for (const y of rows) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const el = gameBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
          if (el) el.classList.add('row-flash');
        }
      }
      setTimeout(() => {
        for (const y0 of rows) { state.board.splice(y0, 1); state.board.unshift(Array(BOARD_WIDTH).fill(null)); }
        onDone();
      }, 180);
    }
    function isTSpin() {
      if (!lastActionWasRotate || state.cur?.type !== 'T') return false;
      const c = { x: state.cur.x + 1, y: state.cur.y + 1 };
      const corners = [
        { x: c.x - 1, y: c.y - 1 }, { x: c.x + 1, y: c.y - 1 },
        { x: c.x - 1, y: c.y + 1 }, { x: c.x + 1, y: c.y + 1 }
      ];
      let occ = 0;
      for (const { x, y } of corners) {
        if (x < 0 || x >= BOARD_WIDTH || y >= BOARD_HEIGHT) { occ++; continue; }
        if (y >= 0 && state.board[y][x]) occ++;
      }
      return occ >= 3;
    }
    function lockPiece() {
      const p = state.cur;
      for (let py = 0; py < p.shape.length; py++)
        for (let px = 0; px < p.shape[py].length; px++)
          if (p.shape[py][px]) { const x = p.x + px, y = p.y + py; if (y >= 0) state.board[y][x] = p.class; }
      roll.locks++; lockSince = null;

      const rows = filledRows();
      const tspin = isTSpin();
      const hadBlocks = state.board.some(row => row.some(Boolean));

      if (rows.length > 0) {
        if (tspin) { SND.tspin(); } else { SND.line(); }
        animateClearAndApply(rows, () => {
          let gained = LINE_SCORE[rows.length] * Math.max(1, state.level);
          if (tspin) { gained += TSPIN_BONUS; stats.tspins++; }
          if (!state.board.some(row => row.some(Boolean)) && hadBlocks) { gained += PERFECT_CLEAR_BONUS; stats.perfects++; SND.pc(); }
          if (state.symbolic) {
            const misRate = roll.mis / Math.max(1, roll.locks);
            const mult = Math.max(1, 1 + 0.15 * (1 - Math.min(1, misRate)));
            gained = Math.round(gained * mult);
          }
          state.score += gained;
          state.lines += rows.length;
          state.level = Math.floor(state.lines / 10) + 1;

          popNext(); canHold = true;
          if (!validAt(state.board, state.cur, state.cur.x, state.cur.y)) { gameOver(); return; }
          updateDisplay();
          if (tut.practiceMode && tspin) { tutAdvance(); }
        });
      } else {
        popNext(); canHold = true;
        if (!validAt(state.board, state.cur, state.cur.x, state.cur.y)) { gameOver(); return; }
        updateDisplay();
      }
    }
    function hardDrop() {
      let dist = 0;
      while (move(0, 1)) dist++;
      if (dist > 0) { state.score += dist * HARD_POINT; roll.hard++; SND.drop(); }
      lockPiece();
    }
    function rotateCurCW() {
      if (!state.cur) return;
      const r = srsRotateCW(state.cur);
      if (r.ok) {
        state.cur.shape = r.shape; state.cur.x = r.x; state.cur.y = r.y; state.cur.o = r.o;
        lastActionWasRotate = true; lockSince = null; SND.rotate();
      } else {
        roll.mis++; lastActionWasRotate = false;
      }
      updateDisplay();
    }

    // Adaptive
    let adaptClock = 0;
    function adaptTick(dt) {
      if (!state.adaptive || state.gameOver || state.paused) return;
      adaptClock += dt; if (adaptClock < 12000) return; adaptClock = 0;
      const age = (Date.now() - sessionStart) / 1000;
      const lpm = state.lines / Math.max(1, age / 60);
      const misRate = roll.mis / Math.max(1, roll.locks);
      const latency = roll.meanLatency || 120;
      const comfort = (lpm / 1.5) + (1 - Math.min(1, misRate)) + (120 / Math.max(60, latency));
      if (comfort >= 2.0) { LOCK_DELAY = Math.max(200, LOCK_DELAY - 40); state.queueSize = Math.max(3, state.queueSize - 1); }
      else { LOCK_DELAY = Math.min(800, LOCK_DELAY + 40); state.ghost = true; state.queueSize = Math.min(5, Math.max(5, state.queueSize)); }
      optLock.value = String(LOCK_DELAY); drawNext();
    }

    // Loop
    function gravityInterval() { return Math.max(50, INITIAL_SPEED - (state.level - 1) * 50); }
    let lastTs = performance.now();
    function loop(ts) {
      const dt = ts - lastTs; lastTs = ts;
      if (!state.paused && !state.gameOver) {
        state.acc += dt; const g = gravityInterval();
        while (state.acc >= g) {
          state.acc -= g;
          if (!move(0, 1)) {
            const now = performance.now();
            if (lockSince === null) lockSince = now;
            if (now - lockSince >= LOCK_DELAY) { lockPiece(); }
            break;
          }
        }
        if (state.downHeld) { if (move(0, 1)) { state.score += SOFT_POINT; roll.soft++; } }
        adaptTick(dt);
        updateDisplay();
      }
      loopHandle = requestAnimationFrame(loop);
    }

    // Telemetry
    function markInput() {
      const now = performance.now(), dt = now - roll.lastInputAt;
      roll.lastInputAt = now; roll.inputs++;
      roll.meanLatency = roll.meanLatency === 0 ? dt : 0.9 * roll.meanLatency + 0.1 * dt;
    }
    function pushClassRow(status) {
      const dur = Math.round((Date.now() - sessionStart) / 1000);
      const row = {
        ts: new Date().toISOString(), status: status, score: state.score, lines: state.lines, level: state.level, dur_s: dur,
        inputs: roll.inputs, latency_ms: Math.round(roll.meanLatency), soft: roll.soft, hard: roll.hard, mis: roll.mis, locks: roll.locks,
        tspins: stats.tspins, perfects: stats.perfects
      };
      const arr = JSON.parse(store.get(CLASS_KEY, "[]")); arr.push(row);
      if (!store.set(CLASS_KEY, JSON.stringify(arr))) console.warn("Could not persist class log.");
    }
    function exportCSV() {
      const arr = JSON.parse(store.get(CLASS_KEY, "[]"));
      if (!Array.isArray(arr) || arr.length === 0) { alert("No session data to export yet."); return; }
      const cols = ["ts", "status", "score", "lines", "level", "dur_s", "inputs", "latency_ms", "soft", "hard", "mis", "locks", "tspins", "perfects"];
      const head = cols.join(","), body = arr.map(r => cols.map(k => r?.[k] ?? "").join(",")).join("\n");
      try {
        const blob = new Blob([head + "\n" + body], { type: "text/csv" }); const url = URL.createObjectURL(blob);
        const a = document.createElement("a"); a.href = url; a.download = "mc_tetris_classlog.csv"; a.click(); URL.revokeObjectURL(url);
      } catch (e) { alert("Export failed in this browser."); }
    }

    // Lifecycle
    function startGame() {
      LOCK_DELAY = +optLock.value;
      const adaptive = optAdaptive.checked, ghost = optGhost.checked, symbolic = optSymbolic.checked, qsize = +optQueue.value;
      rngSeed = optDaily.checked ? dailySeed() : ((+optSeed.value) || Math.floor(Math.random() * 1e9)) >>> 0;

      state = {
        board: [], cur: null, hold: null, score: 0, lines: 0, level: 1, paused: false, gameOver: false,
        acc: 0, downHeld: false, gameStarted: true, adaptive: adaptive, ghost: ghost, symbolic: symbolic, queueSize: qsize
      };

      sessionStart = Date.now();
      stats.tspins = 0; stats.perfects = 0;
      roll.inputs = roll.soft = roll.hard = roll.mis = roll.locks = 0; roll.meanLatency = 0; roll.lastInputAt = performance.now();
      lastActionWasRotate = false;

      makeBoard(); queue = newBag(); popNext(); drawHold(); drawNext(); updateDisplay();

      startModal.classList.add('hidden'); gameOverModal.classList.add('hidden');
      startBtn.classList.add('hidden'); pauseBtn.classList.remove('hidden');

      cancelAnimationFrame(loopHandle); lastTs = performance.now(); requestAnimationFrame(loop);
    }
    function gameOver() {
      state.gameOver = true; cancelAnimationFrame(loopHandle); SND.over();
      mustGet('finalScore').textContent = String(state.score);
      mustGet('finalLines').textContent = String(state.lines);
      mustGet('finalLevel').textContent = String(state.level);
      const secs = Math.max(1, Math.round((Date.now() - sessionStart) / 1000));
      const lpm = (state.lines / (secs / 60)).toFixed(1);
      mustGet('finalLPM').textContent = String(lpm);
      mustGet('finalTSpins').textContent = String(stats.tspins);
      mustGet('finalPCs').textContent = String(stats.perfects);
      gameOverModal.classList.remove('hidden'); pauseBtn.classList.add('hidden'); startBtn.classList.remove('hidden');
      pushClassRow('gameover');
    }
    function togglePause() {
      if (!state.gameStarted || state.gameOver) return;
      state.paused = !state.paused;
      if (state.paused) { pauseModal.classList.remove('hidden'); pauseBtn.textContent = 'RESUME'; pushClassRow('pause'); }
      else { pauseModal.classList.add('hidden'); pauseBtn.textContent = 'PAUSE'; lastTs = performance.now(); }
    }

    // Keybinds
    const DEFAULT_KEYS = { left: 'ArrowLeft', right: 'ArrowRight', down: 'ArrowDown', rotate: 'ArrowUp', hard: 'Enter', hold: 'Shift', pause: 'p' };
    function loadKeys() { return { ...DEFAULT_KEYS, ...JSON.parse(store.get('mc_kb', "{}")) }; }
    function saveKeys(map) { store.set('mc_kb', JSON.stringify(map)); }
    let KEYS = loadKeys();
    function openKeybinds() {
      kb.left.value = KEYS.left; kb.right.value = KEYS.right; kb.down.value = KEYS.down; kb.rotate.value = KEYS.rotate;
      kb.hard.value = KEYS.hard; kb.hold.value = KEYS.hold; kb.pause.value = KEYS.pause;
      keysModal.classList.remove('hidden');
    }
    kb.save.addEventListener('click', () => {
      KEYS = {
        left: kb.left.value || DEFAULT_KEYS.left, right: kb.right.value || DEFAULT_KEYS.right, down: kb.down.value || DEFAULT_KEYS.down,
        rotate: kb.rotate.value || DEFAULT_KEYS.rotate, hard: kb.hard.value || DEFAULT_KEYS.hard, hold: kb.hold.value || DEFAULT_KEYS.hold,
        pause: kb.pause.value || DEFAULT_KEYS.pause
      };
      saveKeys(KEYS); keysModal.classList.add('hidden');
    });
    kb.cancel.addEventListener('click', () => keysModal.classList.add('hidden'));

    // Input
    document.addEventListener('keydown', (e) => {
      if (!state.gameStarted) {
        if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); startGame(); }
        return;
      }
      if (state.gameOver) {
        if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); startGame(); }
        return;
      }
      const k = e.key;
      if (k === KEYS.left) { e.preventDefault(); if (state.cur) { move(-1, 0); markInput(); updateDisplay(); } }
      else if (k === KEYS.right) { e.preventDefault(); if (state.cur) { move(1, 0); markInput(); updateDisplay(); } }
      else if (k === KEYS.down) { e.preventDefault(); state.downHeld = true; markInput(); }
      else if (k === KEYS.rotate || k === ' ') { e.preventDefault(); rotateCurCW(); markInput(); }
      else if (k === KEYS.hard) { e.preventDefault(); hardDrop(); markInput(); }
      else if (k === KEYS.hold || k === 'c' || k === 'C') { e.preventDefault(); holdSwap(); markInput(); }
      else if (k.toLowerCase() === KEYS.pause.toLowerCase()) { e.preventDefault(); togglePause(); }
    });
    document.addEventListener('keyup', (e) => { if (e.key === KEYS.down) state.downHeld = false; });

    // Buttons
    startBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', togglePause);
    rotateBtn.addEventListener('click', () => rotateCurCW());
    dropBtn.addEventListener('click', () => hardDrop());
    holdBtn.addEventListener('click', () => holdSwap());
    exportBtn.addEventListener('click', () => exportCSV());
    keysBtn.addEventListener('click', () => openKeybinds());
    tutorialBtn.addEventListener('click', () => openTutorial());
    [...document.querySelectorAll('.btn')].forEach(b => b.addEventListener('touchstart', e => { e.preventDefault(); b.click(); }, { passive: false }));

    // Tutorial
    const slides = [
      {
        title: "Welcome",
        html: `<p>This short tutorial explains controls, the 7-bag randomizer, lock delay, ghost piece, SRS wall-kicks, and T-Spins.</p>
               <p>Use the buttons below to navigate. You can exit anytime.</p>`
      },
      {
        title: "Controls",
        html: `<ul class="tut-list">
                <li>Move: <b>← →</b>, Soft Drop: <b>↓</b>, Hard Drop: <b>Enter</b></li>
                <li>Rotate: <b>↑</b> or <b>Space</b>, Hold: <b>C</b> or <b>Shift</b></li>
                <li>Pause: <b>P</b>. Rebind keys in <b>KEY BINDS</b>.</li>
               </ul>`
      },
      {
        title: "7-Bag & Lock Delay",
        html: `<p>Pieces are dealt from shuffled sets of all 7 tetrominoes — a <b>7-bag</b>. This avoids long droughts.</p>
               <p><b>Lock delay</b> gives you a short window to adjust a piece after it lands. We show a ghost piece that <i>pulses</i> when lock timing starts.</p>`
      },
      {
        title: "SRS & Wall-Kicks",
        html: `<p>We use <b>SRS</b> (Super Rotation System). When rotating near walls or stacks, the piece can "kick" sideways to complete the rotation.</p>
               <p>This makes tight placements possible.</p>`
      },
      {
        title: "Hands-on: T-Spin Drill",
        html: `<p>Goal: Perform a <b>T-Spin Single</b>.</p>
               <ol class="tut-list">
                 <li>We'll pre-load the board with a T-slot.</li>
                 <li>Spawn a <b>T</b> piece. Rotate into the slot and lock it.</li>
                 <li>You'll see a success banner when detected.</li>
               </ol>
               <p>Press <b>Start Drill</b> to enter practice. Use your normal controls.</p>
               <div style="margin-top:.6rem;display:flex;gap:.6rem;justify-content:center;">
                 <button class="btn" id="startDrillBtn">Start Drill</button>
               </div>`
      },
      {
        title: "Nice!",
        html: `<p>You completed the T-Spin drill. In real games, T-Spins give bonus points — we add +${TSPIN_BONUS} on scoring, plus line clears.</p>
               <p>Ready to play for real? Close tutorial and hit <b>START GAME</b>.</p>`
      }
    ];
    function openTutorial() {
      tut.step = 0; tut.active = true; tut.practiceMode = false;
      renderSlide();
      tutorialModal.classList.remove('hidden');
    }
    function closeTutorial() {
      tut.active = false; tut.practiceMode = false;
      tutorialModal.classList.add('hidden');
      if (!state.gameStarted) startModal.classList.remove('hidden');
    }
    function renderSlide() {
      const s = slides[tut.step];
      tut.body.innerHTML = `<h3 style="margin-bottom:.5rem">${s.title}</h3>${s.html}`;
      tut.prev.disabled = (tut.step === 0);
      tut.next.textContent = (tut.step === slides.length - 1 ? "Done" : "Next");
      const drillBtn = document.getElementById('startDrillBtn');
      if (drillBtn) { drillBtn.addEventListener('click', startDrill); }
    }
    function tutAdvance() {
      if (tut.step < slides.length - 1) { tut.step++; renderSlide(); }
      else { closeTutorial(); }
    }
    function tutBack() { if (tut.step > 0) { tut.step--; renderSlide(); } }
    tut.next.addEventListener('click', () => tutAdvance());
    tut.prev.addEventListener('click', () => tutBack());
    tut.exit.addEventListener('click', () => closeTutorial());
    function startDrill() {
      tut.practiceMode = true;
      tutorialModal.classList.add('hidden');
      state = {
        board: [], cur: null, hold: null, score: 0, lines: 0, level: 1,
        paused: false, gameOver: false, acc: 0, downHeld: false, gameStarted: true,
        adaptive: false, ghost: true, symbolic: false, queueSize: 3
      };
      makeBoard();
      for (let y = BOARD_HEIGHT - 4; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const leave = (
            (y === BOARD_HEIGHT - 3 && (x === 4)) ||
            (y === BOARD_HEIGHT - 2 && (x === 3 || x === 5)) ||
            (y === BOARD_HEIGHT - 1 && (x === 4))
          );
          if (!leave) state.board[y][x] = 'color-J';
        }
      }
      queue = ['T', 'I', 'L', 'S', 'Z', 'J', 'O'];
      popNext();
      state.cur.y = 14; state.cur.x = 4;
      drawHold(); drawNext(); updateDisplay();
      cancelAnimationFrame(loopHandle); lastTs = performance.now(); requestAnimationFrame(loop);
    }

    // Boot
    try { makeBoard(); drawHold(); drawNext(); } catch (e) { console.error(e); gameBoard.innerHTML = '<div style="color:#ff5a5a;padding:1rem;text-align:center;">Load error. See console.</div>'; }
    window.startGame = startGame;
    window.openTutorial = openTutorial;
  </script>
</body>
</html>
